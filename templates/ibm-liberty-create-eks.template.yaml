AWSTemplateFormatVersion: 2010-09-09
Description: This template creates an EKS cluster using eksctl from an EC2 instance. (qs-1tdrmii8p)
Metadata:
  ParameterLabels:
      EKSClusterName:
        default: EKS Cluster Name
Parameters:
  BootNodeInstanceId:
    Type: AWS::EC2::Instance::Id
    Description: Boot Node Instance Id
  EKSClusterName:
    Type: String
    Description: Name for the new cluster*.
  LaunchType:
    Type: String
    AllowedValues: [ EC2 ]
    Default: EC2
    Description: Select which launch type to use for your EKS cluster*.
Conditions:
  IsFargate: !Equals
    - !Ref LaunchType
    - Fargate
Resources:
  SpecificInstanceIdAssociation:
    Type: AWS::SSM::Association
    Properties:
      Name: AWS-RunShellScript
      Targets:
      - Key: InstanceIds
        Values:
        - !Ref BootNodeInstanceId
      Parameters:
        commands:
        - |
          #!/bin/bash
          curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin
        - !If
          - IsFargate
          - !Sub |
            #!/bin/bash
            eksctl create cluster --fargate --name ${EKSClusterName} --region ${AWS::Region} > /tmp/eksctl_create_cluster.log
          - !Sub |
            #!/bin/bash
            eksctl create cluster --name ${EKSClusterName} --region ${AWS::Region} > /tmp/eksctl_create_cluster.log
        workingDirectory:
        - /tmp
      WaitForSuccessTimeoutSeconds: 1200

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonEC2RoleforSSM
      Path: /
      Policies:
        - PolicyName: IBMLibertySSMLimitedAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                  - ssm:PutParameter
                  - ssm:GetParameter
                  - ssm:DeleteParameter
                Resource: !Sub arn:${AWS::Partition}:ssm:*:${AWS::AccountId}:parameter/*
              - Effect: Allow
                Action:
                  - logs:FilterLogEvents
                Resource: !Sub arn:${AWS::Partition}:logs:*:${AWS::AccountId}:log-group:*
        - PolicyName: IBMLibertyEC2LimitedAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                  - ec2:StartInstances
                Resource:
                  - !Sub arn:${AWS::Partition}:license-manager:*:${AWS::AccountId}:license-configuration/*
                  - !Sub arn:${AWS::Partition}:ec2:*:${AWS::AccountId}:instance/*

  CleanUpLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import os
          import traceback
          import time

          def handler(event, context):
              responseData = {}
              try:
                if event['RequestType'] == 'Delete':
                  print("Run destroy script")

                  ssm = boto3.client('ssm', region_name=os.environ['Region'])
                  ec2 = boto3.resource('ec2')

                  instanceID = os.environ['BootNode']
                  stackName = os.environ['StackName']
                  parameterName = stackName + "_CleanupStatus"

                  instance = ec2.Instance(instanceID)
                  if instance.state.get('Name') != 'running':
                    print("Boot node is not running. Starting now...")
                    instance.start()
                    instance.wait_until_running()

                  response = ssm.send_command(Targets=[{"Key":"instanceids","Values":[instanceID]}],
                          DocumentName="AWS-RunShellScript",
                          Parameters={"commands":[f"/tmp/scripts/destroy.sh {parameterName}"],
                                      "executionTimeout":["1800"],
                                      "workingDirectory":["/tmp/scripts"]},
                          Comment="Execute script to delete EKS cluster",
                          TimeoutSeconds=180)

                  print("Response:", response)

                  current_status = "RUNNING"
                  final_status = "COMPLETE"
                  response = ssm.put_parameter(Name=parameterName,
                          Description="Waiting for CleanupStatus to be COMPLETE",
                          Value=current_status,
                          Type='String',
                          Overwrite=True)
                  print(response)

                  while current_status != final_status:
                    time.sleep(30)
                    response = ssm.get_parameter(Name=parameterName)
                    parameter = response.get('Parameter')
                    current_status = parameter.get('Value')
                    print(f"Waiting for destroy.sh script to complete (current status: {current_status})")

                  ssm.delete_parameter(Name=parameterName)

                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, '')

              except Exception as e:
                print(e)
                traceback.print_exc()
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, '')
      Environment:
        Variables:
          Region: !Ref AWS::Region
          BootNode: !Ref BootNodeInstanceId
          StackName: !Ref AWS::StackName
      Handler: index.handler
      Role: !GetAtt 'LambdaExecutionRole.Arn'
      Runtime: python3.7
      Timeout: 900

  Cleanup:
    Type: Custom::Cleanup
    Properties:
      ServiceToken: !GetAtt 'CleanUpLambda.Arn'
Outputs:
  EKSName:
    Description: EKS cluster name
    Value: !Ref EKSClusterName
  LaunchType:
    Description: Launch type of the new cluster
    Value: !Ref LaunchType
